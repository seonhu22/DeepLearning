# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ChzPewawNUm7IZp77b7BFUceSASWuK6t
"""

from keras.datasets import cifar10

(x_train, y_train), (x_test, y_test) = cifar10.load_data()
classes = ['airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']

print(x_train.shape)
print(x_test.shape)
print(y_train.shape)

x_train = x_train / 255.
x_test = x_test / 255.

from keras.utils import to_categorical   # to_categorical = 숫자로 만들어진 array를 one-hot vector array로 변환

y_train = to_categorical(y_train, num_classes = 10)
y_test = to_categorical(y_test, num_classes = 10)

# 이미지 파일에 Fully Connected MLP는 비효율적(Dense()), CNN이 효율적(Con2D()) -> 이미지에 특화된 함수 -> Convolution Nerual Network
# BatchNormallization, Running Weight

from keras.layers import *
from keras.models import Model, Sequential
def build_model():
    x = Input(shape = (32, 32, 3))
    out = Sequential()(x)

    out = Conv2D(32, (3, 3), padding = 'same', activation = 'relu')(out)
    out = Conv2D(64, (3, 3), padding = 'same', activation = 'relu')(out)
    out = MaxPooling2D(pool_size = 2)(out)   # pool_size = 전체 크기를 절반으로 줄임
    out = Dropout(0.3)(out)
    out = Conv2D(64, (3, 3), padding = 'same', activation = 'relu')(out)
    out = Conv2D(128, (5, 5), padding = 'same', activation = 'relu')(out)
    out = MaxPooling2D(pool_size = 2)(out) 
    out = Dropout(0.5)(out)
    out = Flatten()(out)
    out = Dense(256, activation = 'relu')(out)
    out = Dense(10, activation = 'softmax')(out)

    model = Model(x,out, name = 'MNIST')
    return model

model = build_model()
model.summary()

model.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])
model.fit(x_train, y_train, batch_size = 32, epochs = 100, validation_data = (x_test, y_test))   # validation = 중간점검

import numpy as np
import matplotlib.pyplot as plt

preds = model.predict(x_test)
preds = np.argmax(preds, axis = 1)

for x, y, p in zip(x_test, y_test, preds):
    y = np.argmax(y)
    if y == p:
        continue
    plt.imshow(x, cmap = 'gray')
    plt.title(f'Pred: {classes[p]} / True: {classes[y]}')
    plt.show()
